---
interface Props {
  name?: string;
  accept?: string;
  label?: string;
  currentUrl?: string;
}

const {
  name = 'media_url',
  accept = 'image/jpeg,image/png,image/webp,image/gif,video/mp4',
  label = 'Upload File',
  currentUrl = '',
} = Astro.props;

const instanceId = `file-upload-${name.replace(/[^a-zA-Z0-9]/g, '-')}`;
---

<div class="file-upload-wrapper" data-instance={instanceId}>
  <label class="block text-sm font-semibold mb-2">{label}</label>

  <!-- Hidden input that stores the URL for form submission -->
  <input
    type="hidden"
    name={name}
    class="file-upload-url-input"
    value={currentUrl}
  />

  <!-- Current / uploaded URL display -->
  <div class="file-upload-current mb-3" style={currentUrl ? '' : 'display:none'}>
    <div class="flex items-center gap-3 p-3 bg-neutral-50 border border-neutral-200 rounded">
      <img
        src={currentUrl}
        alt="Current file"
        class="file-upload-preview-thumb w-16 h-16 object-cover rounded border border-neutral-200"
        style={currentUrl && !currentUrl.match(/\.(mp4|mov|avi|webm)$/i) ? '' : 'display:none'}
      />
      <video
        src={currentUrl}
        muted
        controls
        class="file-upload-preview-video w-24 h-16 object-cover rounded border border-neutral-200"
        style={currentUrl && currentUrl.match(/\.(mp4|mov|avi|webm)$/i) ? '' : 'display:none'}
      ></video>
      <div class="flex-1 min-w-0">
        <p class="text-sm text-green-700 font-medium">File uploaded</p>
        <p class="text-xs text-neutral-500 truncate file-upload-url-display">{currentUrl}</p>
      </div>
      <button
        type="button"
        class="file-upload-remove-btn px-3 py-1.5 text-xs text-red-600 border border-red-200 rounded hover:bg-red-50"
      >
        Remove
      </button>
    </div>
  </div>

  <!-- Drop zone -->
  <div
    class="file-upload-dropzone border-2 border-dashed border-neutral-300 rounded p-6 text-center cursor-pointer hover:border-neutral-400 transition-colors"
    style={currentUrl ? 'display:none' : ''}
  >
    <input
      type="file"
      accept={accept}
      class="file-upload-file-input sr-only"
    />

    <!-- Idle state -->
    <div class="file-upload-idle">
      <svg class="mx-auto mb-3 w-8 h-8 text-neutral-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
        <path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" />
      </svg>
      <p class="text-sm text-neutral-600 mb-1">Drag & drop a file here, or <span class="text-neutral-900 underline">browse</span></p>
      <p class="text-xs text-neutral-400">Images are compressed to WebP before upload</p>
    </div>

    <!-- Preview state (after file selected, before/during upload) -->
    <div class="file-upload-preview" style="display:none">
      <img
        src=""
        alt="Preview"
        class="file-upload-preview-img mx-auto mb-3 max-h-40 rounded border border-neutral-200"
      />
      <video
        src=""
        muted
        controls
        class="file-upload-preview-vid mx-auto mb-3 max-h-40 rounded border border-neutral-200"
        style="display:none"
      ></video>
      <p class="text-sm text-neutral-600 file-upload-filename"></p>
      <p class="text-xs text-neutral-400 file-upload-filesize"></p>
    </div>

    <!-- Progress bar -->
    <div class="file-upload-progress mt-4" style="display:none">
      <div class="w-full bg-neutral-200 rounded-full h-1.5">
        <div class="file-upload-progress-bar bg-neutral-900 h-1.5 rounded-full transition-all duration-300" style="width: 0%"></div>
      </div>
      <p class="text-xs text-neutral-500 mt-1.5 file-upload-progress-text">Compressing...</p>
    </div>

    <!-- Error state -->
    <div class="file-upload-error mt-3" style="display:none">
      <p class="text-sm text-red-600 file-upload-error-msg"></p>
    </div>
  </div>
</div>

<script>
  import imageCompression from 'browser-image-compression';

  function initFileUpload(wrapper: HTMLElement) {
    const instanceId = wrapper.dataset.instance;
    if (!instanceId || wrapper.dataset.initialized === 'true') return;
    wrapper.dataset.initialized = 'true';

    const urlInput = wrapper.querySelector('.file-upload-url-input') as HTMLInputElement;
    const currentDisplay = wrapper.querySelector('.file-upload-current') as HTMLElement;
    const previewThumb = wrapper.querySelector('.file-upload-preview-thumb') as HTMLImageElement;
    const urlDisplay = wrapper.querySelector('.file-upload-url-display') as HTMLElement;
    const removeBtn = wrapper.querySelector('.file-upload-remove-btn') as HTMLButtonElement;
    const dropzone = wrapper.querySelector('.file-upload-dropzone') as HTMLElement;
    const fileInput = wrapper.querySelector('.file-upload-file-input') as HTMLInputElement;
    const idleState = wrapper.querySelector('.file-upload-idle') as HTMLElement;
    const previewState = wrapper.querySelector('.file-upload-preview') as HTMLElement;
    const previewImg = wrapper.querySelector('.file-upload-preview-img') as HTMLImageElement;
    const previewVid = wrapper.querySelector('.file-upload-preview-vid') as HTMLVideoElement;
    const previewVideo = wrapper.querySelector('.file-upload-preview-video') as HTMLVideoElement;
    const filenameEl = wrapper.querySelector('.file-upload-filename') as HTMLElement;
    const filesizeEl = wrapper.querySelector('.file-upload-filesize') as HTMLElement;
    const progressWrap = wrapper.querySelector('.file-upload-progress') as HTMLElement;
    const progressBar = wrapper.querySelector('.file-upload-progress-bar') as HTMLElement;
    const progressText = wrapper.querySelector('.file-upload-progress-text') as HTMLElement;
    const errorWrap = wrapper.querySelector('.file-upload-error') as HTMLElement;
    const errorMsg = wrapper.querySelector('.file-upload-error-msg') as HTMLElement;

    function formatBytes(bytes: number): string {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function showError(msg: string) {
      errorMsg.textContent = msg;
      errorWrap.style.display = '';
    }

    function hideError() {
      errorWrap.style.display = 'none';
      errorMsg.textContent = '';
    }

    function resetToIdle() {
      idleState.style.display = '';
      previewState.style.display = 'none';
      progressWrap.style.display = 'none';
      previewVid.style.display = 'none';
      previewVid.src = '';
      hideError();
      fileInput.value = '';
    }

    function showUploadedState(url: string) {
      urlInput.value = url;
      urlDisplay.textContent = url;

      const isVideoUrl = url && /\.(mp4|mov|avi|webm)$/i.test(url);

      // Show thumbnail for images, video element for videos
      if (isVideoUrl) {
        previewThumb.style.display = 'none';
        previewVideo.src = url;
        previewVideo.style.display = '';
      } else if (url) {
        previewThumb.src = url;
        previewThumb.style.display = '';
        previewVideo.style.display = 'none';
      } else {
        previewThumb.style.display = 'none';
        previewVideo.style.display = 'none';
      }

      currentDisplay.style.display = '';
      dropzone.style.display = 'none';
    }

    function clearUploaded() {
      urlInput.value = '';
      urlDisplay.textContent = '';
      previewThumb.src = '';
      previewVideo.src = '';
      previewVideo.style.display = 'none';
      currentDisplay.style.display = 'none';
      dropzone.style.display = '';
      resetToIdle();
    }

    // Remove button
    removeBtn.addEventListener('click', clearUploaded);

    // Click dropzone to open file picker
    dropzone.addEventListener('click', (e) => {
      if (e.target === fileInput) return;
      fileInput.click();
    });

    // Drag and drop
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('border-neutral-500', 'bg-neutral-50');
    });

    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('border-neutral-500', 'bg-neutral-50');
    });

    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('border-neutral-500', 'bg-neutral-50');
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    });

    // File input change
    fileInput.addEventListener('change', () => {
      if (fileInput.files && fileInput.files.length > 0) {
        handleFile(fileInput.files[0]);
      }
    });

    async function handleFile(file: File) {
      hideError();

      const isVideo = file.type.startsWith('video/');
      const isImage = file.type.startsWith('image/');

      if (!isImage && !isVideo) {
        showError('Unsupported file type. Use JPG, PNG, WebP, GIF, or MP4.');
        return;
      }

      // Show preview for images or videos
      if (isImage) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewImg.src = e.target?.result as string;
          previewImg.style.display = '';
        };
        reader.readAsDataURL(file);
        previewVid.style.display = 'none';
      } else if (isVideo) {
        previewImg.style.display = 'none';
        previewVid.src = URL.createObjectURL(file);
        previewVid.style.display = '';
      } else {
        previewImg.style.display = 'none';
        previewVid.style.display = 'none';
      }

      filenameEl.textContent = file.name;
      filesizeEl.textContent = formatBytes(file.size);
      idleState.style.display = 'none';
      previewState.style.display = '';

      // Validate video size (max 100MB)
      if (isVideo && file.size > 100 * 1024 * 1024) {
        showError('Video too large. Maximum 100MB.');
        return;
      }

      // Show progress
      progressWrap.style.display = '';
      progressBar.style.width = '0%';

      let fileToUpload: File = file;

      // Compress images client-side
      if (isImage) {
        try {
          progressText.textContent = 'Compressing...';
          progressBar.style.width = '20%';

          const compressed = await imageCompression(file, {
            maxSizeMB: 2,
            maxWidthOrHeight: 1920,
            useWebWorker: true,
            fileType: 'image/webp',
            initialQuality: 0.8,
            onProgress: (progress: number) => {
              // Map compression progress to 20-50% of total bar
              const mapped = 20 + (progress * 0.3);
              progressBar.style.width = mapped + '%';
            },
          });

          fileToUpload = new File(
            [compressed],
            file.name.replace(/\.[^.]+$/, '.webp'),
            { type: 'image/webp' },
          );

          filesizeEl.textContent = `${formatBytes(file.size)} -> ${formatBytes(fileToUpload.size)} (compressed)`;
          progressBar.style.width = '50%';
        } catch (err) {
          console.error('Compression error:', err);
          showError('Image compression failed. Try a different file.');
          progressWrap.style.display = 'none';
          return;
        }
      } else {
        progressBar.style.width = '50%';
      }

      // Upload to /api/upload
      try {
        progressText.textContent = 'Uploading...';

        const formData = new FormData();
        formData.append('file', fileToUpload);

        const xhr = new XMLHttpRequest();

        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            // Map upload progress to 50-95%
            const pct = 50 + (e.loaded / e.total) * 45;
            progressBar.style.width = pct + '%';
          }
        });

        const result = await new Promise<{ url?: string; error?: string }>((resolve, reject) => {
          xhr.onload = () => {
            try {
              const data = JSON.parse(xhr.responseText);
              resolve(data);
            } catch {
              reject(new Error('Invalid server response'));
            }
          };
          xhr.onerror = () => reject(new Error('Upload failed'));
          xhr.open('POST', '/api/upload');
          xhr.send(formData);
        });

        if (result.error) {
          showError(result.error);
          progressWrap.style.display = 'none';
          return;
        }

        if (result.url) {
          progressBar.style.width = '100%';
          progressText.textContent = 'Done!';

          // Brief delay to show 100% then switch to uploaded state
          setTimeout(() => {
            showUploadedState(result.url!);
            resetToIdle();
          }, 400);
        }
      } catch (err) {
        console.error('Upload error:', err);
        showError('Upload failed. Please try again.');
        progressWrap.style.display = 'none';
      }
    }
  }

  // Initialize all file upload instances on the page
  document.querySelectorAll<HTMLElement>('.file-upload-wrapper').forEach(initFileUpload);
</script>
