---
interface Props {
  src: string;
  poster?: string;
  title: string;
}

const { src, poster, title } = Astro.props;

const isCloudflareStream = src.includes('cloudflarestream.com');

function buildStreamUrl(url: string, posterUrl?: string): string {
  const base = url.replace(/\/manifest\/video\.m3u8$/, '');
  const iframeSrc = base.includes('/iframe') ? base : `${base}/iframe`;
  const params = new URLSearchParams({
    autoplay: 'true',
    muted: 'true',
    loop: 'true',
    controls: 'false',
  });
  if (posterUrl) {
    params.set('poster', posterUrl);
  }
  return `${iframeSrc}?${params.toString()}`;
}

const iframeSrc = isCloudflareStream ? buildStreamUrl(src, poster) : null;

const playerId = `vp-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  class="video-player relative w-full h-full"
  id={playerId}
  data-playing="false"
  data-mode="loop"
>
  {isCloudflareStream ? (
    <iframe
      src={iframeSrc}
      title={title}
      allow="autoplay; fullscreen"
      allowfullscreen
      class="w-full h-full border-0"
      loading="lazy"
    />
  ) : (
    <div class="video-wrap relative w-full h-full">
      {poster && (
        <img
          src={poster}
          alt=""
          class="video-poster absolute inset-0 w-full h-full object-cover z-[1]"
          data-poster-img
        />
      )}
      <video
        data-src={src}
        poster={poster ?? undefined}
        preload="metadata"
        muted
        playsinline
        loop
        class="w-full h-full object-cover block"
        data-video
      />
      <div class="video-loading absolute inset-0 pointer-events-none opacity-0 z-[2]" data-loading />
    </div>
  )}

  {/* Play/pause overlay — play icon when paused, pause icon on hover when playing */}
  <div class="play-overlay absolute inset-0 flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-200 z-[3]">
    <svg class="play-icon" width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <polygon points="12,8 34,20 12,32" fill="white" fill-opacity="0.5" />
    </svg>
    <svg class="pause-icon" width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <rect x="10" y="8" width="7" height="24" fill="white" fill-opacity="0.5" />
      <rect x="23" y="8" width="7" height="24" fill="white" fill-opacity="0.5" />
    </svg>
  </div>

  <button
    class="absolute inset-0 w-full h-full cursor-pointer bg-transparent border-0 p-0 m-0 z-[4]"
    aria-label={`Play or pause ${title}`}
    data-toggle
  />
</div>

<style>
  .video-poster {
    transition: opacity 0.5s ease;
  }
  .video-player[data-playing="true"] .video-poster {
    opacity: 0;
    pointer-events: none;
  }

  /* Default: hide both icons */
  .play-icon { display: block; }
  .pause-icon { display: none; }

  /* Show play icon when manually paused */
  .video-player[data-mode="paused"] .play-overlay {
    opacity: 1;
  }

  /* Show pause icon on hover while playing */
  .video-player[data-playing="true"]:hover .play-overlay {
    opacity: 1;
  }
  .video-player[data-playing="true"] .play-icon { display: none; }
  .video-player[data-playing="true"] .pause-icon { display: block; }

  .video-loading {
    background: rgba(0, 0, 0, 0.3);
    transition: opacity 0.3s ease;
  }
  .video-loading.is-loading {
    opacity: 1;
    animation: pulse-load 1.5s ease-in-out infinite;
  }
  @keyframes pulse-load {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
  }
</style>

<script>
  const MAX_CONCURRENT = 3;
  const activePlayers = new Set<HTMLDivElement>();

  function initVideoPlayers() {
    const players = document.querySelectorAll<HTMLDivElement>('.video-player');
    const bound = new WeakSet<HTMLDivElement>();

    players.forEach((player) => {
      if (bound.has(player)) return;
      bound.add(player);

      const toggle = player.querySelector<HTMLButtonElement>('[data-toggle]');
      const video = player.querySelector<HTMLVideoElement>('[data-video]');
      const iframe = player.querySelector<HTMLIFrameElement>('iframe');

      if (!toggle) return;

      // --- Click: toggle play/pause ---
      if (video) {
        toggle.addEventListener('click', () => {
          if (player.dataset.mode === 'paused') {
            player.dataset.mode = 'loop';
            loadVideo(player, video);
            video.play().catch(() => {});
            activePlayers.add(player);
            enforceLimit(player);
          } else {
            video.pause();
            player.dataset.mode = 'paused';
            activePlayers.delete(player);
          }
        });

        video.addEventListener('pause', () => { player.dataset.playing = 'false'; });
        video.addEventListener('play', () => { player.dataset.playing = 'true'; });
      } else if (iframe) {
        let playing = true;
        toggle.addEventListener('click', () => {
          if (playing) {
            iframe.contentWindow?.postMessage({ type: 'pause' }, '*');
            playing = false;
            player.dataset.playing = 'false';
          } else {
            iframe.contentWindow?.postMessage({ type: 'play' }, '*');
            playing = true;
            player.dataset.playing = 'true';
          }
        });
      }

      // --- IntersectionObserver: autoplay loop while in viewport ---
      if (video) {
        const dataSrc = video.dataset.src;
        if (!dataSrc) return;

        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (player.dataset.mode === 'paused') return;

              if (entry.isIntersecting) {
                if (prefersReducedMotion) return;
                player.dataset.mode = 'loop';
                loadVideo(player, video);
                activePlayers.add(player);
                enforceLimit(player);
                video.play().catch(() => { player.dataset.playing = 'false'; });
              } else {
                video.pause();
                activePlayers.delete(player);
              }
            });
          },
          { rootMargin: '200px 0px', threshold: 0.15 }
        );
        observer.observe(player);
      }
    });
  }

  function loadVideo(player: HTMLDivElement, video: HTMLVideoElement) {
    const dataSrc = video.dataset.src;
    if (!dataSrc) return;
    if (video.src && video.getAttribute('src') !== '') return;

    const loadingEl = player.querySelector<HTMLDivElement>('[data-loading]');
    loadingEl?.classList.add('is-loading');
    video.preload = 'auto';
    video.src = dataSrc;
    const onCanPlay = () => {
      loadingEl?.classList.remove('is-loading');
      video.removeEventListener('canplay', onCanPlay);
      // Retry play after source loads — initial play() may have failed
      if (player.dataset.mode === 'loop') {
        video.play().catch(() => {});
      }
    };
    video.addEventListener('canplay', onCanPlay);
  }

  function enforceLimit(current: HTMLDivElement) {
    if (activePlayers.size <= MAX_CONCURRENT) return;
    for (const p of activePlayers) {
      if (p === current) continue;
      if (activePlayers.size <= MAX_CONCURRENT) break;
      const v = p.querySelector<HTMLVideoElement>('[data-video]');
      if (v) {
        v.pause();
        p.dataset.playing = 'false';
        activePlayers.delete(p);
      }
    }
  }

  initVideoPlayers();
  document.addEventListener('astro:after-swap', () => {
    activePlayers.clear();
    initVideoPlayers();
  });
</script>
